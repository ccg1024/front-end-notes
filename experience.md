---
title: 面经总结
desc: 牛客面试经验
date: 2023-04-11
---
# 面经

### js

- js 中变量类型

7 个基本数据类型：boolean, number, bigInt, string, undefined, null, Symbol

1 个引用数据类型：object

- promise 是什么以及使用方法：

将三种状态，promise 对象方法，微任务，会在宏任务后面立即执行。

- 什么是跨域，如何解决：

同源限制，协议，域名，端口，CORS，node 中间件，JSONP，postmessage。

node 中间件，nginx 反向代理，就是通过代理进行请求发送，前端与代理服务器之间是同源的，然而，服务器之间是不存在同源限制的。

JSONP 的原理是，跨域问题是请求文件产生的，但请求`script`是不会产生跨域问题。同时设置响应头文档类型为`javascript`。因为脚本标签本来就是能够引用网络上的 JS 文件的。使用的是 GET 请求。在不适用 JSONP 的时候，该标签是通过请求拿到脚本文件直接执行，若使用的是 JSONP，则返回的是客户端传过去的回调函数与文件内容（作为回调参数），然后在本地执行回调函数。

postmessage 则是 H5 的新端口，通过发送与接受 API 实现同信。

- JS 中判断变量类型

一共四种方法，typeof，instanceof，Object.prototype.toString.call(obj)对象原型链，constructor 引用数据类型，就是判断实例的构造函数与类的构造函数是否相同，避免了原型链干扰。最精准的就是第三种。

- JS 中实现异步的方式

回调函数，事件监听，setTimeout，Promise，生成器，async/awati。

> 回调函数——Ajax 回调。生成器 ES6 语法，因为该函数不是一次执行完，可以通过 yield 保存不同阶段状态，通过 next 返回。

- 数组去重方法

通过对象属性，就是遍历数组的时候，将数据作为零时对象的属性，若没有，则添加属性，若有，则抛弃数组值，Set 有兼容性问题，filter，reduce+includes 等，filter+indexOf，原理是后者只返回第一个匹配到的数据下标。

- undefined 与 null

undefined 是全局对象的一个属性，声明的变量为赋值，没有返回值的函数返回值。函数形参没有赋值，undefined==undefined，undefined===undefined，访问对象中的不存在属性。

null 代表**对象**的值未设置，相当没有设置指针地址。**null 的 typeof 是 object**。null 是人为设置的值。可以将对象赋值为 null 来释放对象。

- ES6 中的箭头函数

没有 this，从外部获取，没有 arguments，不能用 new，没有原型与 super。

通过`call`与`apply`调用时，第一个参数会被忽略，即无法绑定 this。无法使用`yield`关键字，因此箭头函数也不能够作为生成器函数。

- 说一说 HTML 语义化

语义化标签，利于页面内容结构化，利于无 CSS 页面可读，利于 SEO，利于代码可读。

1. 易于用户阅读，样式文件为加载时，页面结构清晰。

2. 易于 SEO，搜索引擎根据标签来确定上下文与关键字权重

3. 方便屏幕阅读器解析，例如盲人阅读器根据语义渲染网页

4. 利于开发和维护，代码可读性高

- this 指向问题

全局执行上下文、函数执行上下文、this 严格模式下 undefined、非严格模式 window、构造函数新对象本身、普通函数不继承 this、箭头函数无 this、可继承。

关键字由来，在对象内部的函数中使用对象内部的属性是非常普遍的需求，但 JS 作用域机制无法实现，就创造了 this 机制。

从全局执行上下文，函数执行上下文。

- JS 变量提升

注意函数提升是优先于变量，let，const 会有暂时性死区，初始化之前访问会报错。

- HashRouter 与 HistoryRouter 区别

> 二者都是通过浏览器的特性实现的。

1. history 是通过浏览器的历史记录栈 API 实现。hash 则是监听 location 对象的 hash 值变化事件实现。

2. url 差别。

3. 同一个 url 刷新，history 会触发浏览器历史记录栈，而 hash 不会。

4. history 需要后端配置指向 index.html，否则刷新会出现 404 问题。hash 不需要。

> 原理：HashRouter 通过`windown.onhashchange`方法获取新 URL 中的 hash 值。HistoryRouter 则是通过`history.pushState`来实现页面跳转是不触发页面刷新，通过`window.onpopstate`监听前进与后退。

- map 与 forEach 的差别

> 除了自己知道的，map 处理速度是比 forEach 快的，同时方便使用链式调用其他数组方法。

- **Event loop，宏任务，微任务**

得分点：任务挂起，同步任务执行结束，执行队列中异步任务，执行`script`标签内代码，`setTimeout/setInterval`，`ajax`，`postMessage/MessageChannel`，`setImmediate`，`I/O(nodejs)`，`Promise`，`MutationObserver`，`Object.oberve`,`process.nextTick(nodejs)`，每个宏任务中，都包含一个微任务队列。

---

**_浏览器的事件循环机制_**：执行 JS 代码时，遇见同步任务，就直接推入**调用栈**中执行，遇到异步任务，将该任务挂起，等到异步任务有返回之后，推入到队列之中，当**调用栈**中所有同步任务执行完毕，再将任务队列中的任务按顺序推入并执行。如此循环。

**_异步任务_**：异步任务又分为宏任务与微任务。

**宏任务**：任务队列中的任务，称为宏任务，**每个宏任务中都包含一个微任务队列**。

**微任务**：等宏任务中的主要功能都完成后，渲染引擎不着急去执行下一个宏任务，而是执行当前宏任务中的微任务。

宏任务包含：

1. 执行`script`标签内部代码

2. `setTimeout/setInterval`

3. `ajax`

4. `postMessage/MessegeChannel`

5. `setImmediate`

6. `I/O(nodejs)`

7. DOM 事件。

微任务包含:

1. `Promise`

2. `MutationObserver`（监视 dom 元素的改变）

3. `Object.observe`（监视某个对象属性的改变）

4. `process.nextTick(nodejs)`

> 浏览器与 node 环境中，微任务的执行时间不同，node 端中，微任务在事件循环的各个阶段之间执行，而浏览器中是在宏任务执行完后进行。

> 在分析事件循环过程中，**一整块代码就是一个宏任务**，因此，分析过程应该是：同步任务，当前文件中的微任务，文件中记录的宏任务。

---

### css

- 什么是 BFC

块级格式化上下文、独立渲染区域、不会影响边界以外的元素。产生 BFC 的条件：float，position，overflow，display。

使用 BFC 的目的是创建独立的渲染区域，内部的元素渲染不会影响外界。常见的应用场景是清除浮动（就是使用了`float`，属性是让元素沿着其容器的左侧或右侧放置，能够让文本与内联元素环绕它，会部分脱离文档流，也就是元素本身大小不会去撑开父容器。）。在前面的描述中，由于浮动元素脱离文档流，其父容器的渲染就会影响到外部的元素（因为浮动元素不会把父元素撑开）。为了让浮动元素撑开父容器——盒子内部的东西不会跑到外部。将父容器设置为 BFC 就可以了。但有因为浮动是部分脱离，所有，不会有兄弟元素跑到浮动元素的后背，被遮住。

产生方式

1. overflow 非 visible 赋值（最常用为 hidden）

2. float 设置左或右。

3. position 为绝对或固定。

4. display 设置为 flex，inline-block 等。

> 其他相关的内容，IFC（inline formatting context）内联格式化上下文，GFC（grid formatting context）网格布局格式化上下文，display 设置 grid，FFC（Flex formatting context）自适应格式化上下文，display 设置 flex 或 inline-flex。

- 伪类与伪元素：自己查找的

伪类：一种选择器，用于选择处于特定状态的元素，比如鼠标悬浮在某个元素上，某个类型中第一个元素等，就像对文档的某个部分应用了一个类一样。通常接在`:`后面。表现就像为特定部分添加了类。

伪元素：类似伪类，就像往文档中添加了新的 HTML 元素一样，而不是向现有元素上应用类。伪元素通常接在`::`后。例如一个`p`元素中有长文字，那么想让在屏幕上第一行变粗，其他不变，可以在文字上添加新标签，但当屏幕大小改变，则有需要重新调整新标签位置，而伪元素`::first-line`则会一直指向屏幕上第一行的内容，即便动态改变屏幕大小。

- 浮动：脱离文档流，盒子塌陷，影响其他元素排版，伪元素，`overflow:hidden`，标签插入法。

设置浮动元素，块级元素可以在同一行，行内元素可以设置宽高——就是自动转换成行内块。

通过伪元素清除浮动方式，与在父类添加 overflow 是一样的，`.clear-float::after{content:''; display: table; clear: both}`，前面是牛客上的写法，实际上，table 就是创建一个块级元素，clear 的意思是是否让元素移动到他之前的浮动元素下面，content 的内容就是伪元素显示的内容，这里为空。

- css 尺寸设计问题

px，rem，em，vw，vh。注意的是，em 用在其他属性上，是相对于自身字体大小。在移动端的响应式设计中，通过 rem 设置字体，然后，配合不同屏幕尺寸在根节点字体大小不同，展示的内容的字体大小也会相应改变。

- **元素水平垂直居中**

1. 父元素相对定位，目标元素绝对定位，设置 top，left 为 50%，同时移动自动大小的一半`transform: translate(-50%, -50%)`，兼容性最好

2. 父元素设置为 flex，同时设置`justify-content: center; align-items: center`，目前也是主流

3. 父元素设置为 grid，同时设置`justify-content: center; align-items: center`，同 flex

4. 父元素设置为`display: table-cell`，同时设置目标元素为`text-align: center; vertical-align: middle`

- 说一说三栏布局的实现方案

> 圣杯布局、双飞翼布局、三栏高度不定、中间栏内容多先渲染

三栏布局：要求左右两边的盒子宽度固定，中间盒子宽度自适应，盒子高度随着内容撑高。通常中间盒子内容较多，为保证页面渲染快，**在写结构的时候将中间盒子放在左右盒子之前**。实现三栏布局的常用方法是**圣杯布局**与**双飞翼布局**。

圣杯布局实现方案：三个元素放在同一个父元素中，代表中间盒子的元素放在最前，父元素设置左右`padding`，三个盒子全部浮动——左边与中间设置左浮动，右边设置右浮动，设置中间盒子宽度 100%，左右盒子固定宽度，**设置左边盒子`margin-left: -100%`，设置相对定义，左边(`left`)平移自身宽度**。右边盒子设置右边距为自身盒子宽度，最后设置父元素清除浮动，否则父元素无法被撑开。

双飞翼布局实现方案：三个盒子对应三个元素，其中中间盒子套两层，中间盒子内部盒子设置`margin`(用来移除左边盒子对中间盒子的覆盖)。三个盒子全浮动，设置中间盒子宽度 100%，左右盒子固定宽度。左边盒子左边距-100%，右边盒子设置右边距-自身宽度，最后设置父元素清除浮动。(父元素右边需要有 padding，不然右边盒子会不见)

> 加分项：圣杯布局优点：无需添加额外的 dom 节点。缺点：当中间部分的宽度小于左边盒子时，会出现布局混乱。双飞翼布局优点：不会出现布局混乱。缺点：多添加一层 dom 节点。

---

### 浏览器

- 浏览器的垃圾回收机制

> 栈垃圾回收、堆垃圾回收、新生区老生区、Scavenge 算法、标记-清除算法、标记-整理算法、全停顿、增量标记

浏览器垃圾回收机制根据数据的存储方式分为：栈垃圾回收，堆垃圾回收。栈垃圾回收方式简单，当一个函数执行结束后，JS 引擎通过向下移动 ESP(当前执行状态的指针)来销毁该函数保存在栈中的执行上下文。先进后出原则。

**堆垃圾回收**：当函数直接结束后，栈空间处理完了，但堆空间的数据虽然没有被引用，也还是存储在堆空间中。此时，需要垃圾回收器将堆空间中的垃圾数据回收。

为了使垃圾回收达到最好的效果，**根据对象的生命周期，使用不同的垃圾回收算法**。

V8 引擎中，将堆分为**新生代**与**老生代**两个区域，新生代中存放的是生存时间短的对象，老生代中存放的是生存时间久的对象。

新生区中使用**Scavenge 算法（清除算法）**，老生区使用**标记-清除算法与标记-整理算法**。

**Scavenge 算法**

1. 标记：对对象区域中的垃圾进行标记

2. 清除垃圾数据与整理碎片化内存

   > 副垃圾回收器会将存活的对象复制到空闲区域，并有序排列，复制后的区域就没有内存碎片。

3. 角色翻转：完成复制后，对象区域与空闲区域进行角色翻转——原来的对象区域变成空闲区，赋值后的空闲区与变成对象区域。至此完成垃圾回收，同时，这种角色翻转操作能够让新生代中的两块区域无限重复使用

**标记-清除算法**

1. 标记：从一组根元素开始，递归遍历该组根元素，在遍历过程中，能够达到的元素称为活动对象，没有到达的元素判断为垃圾数据，就是运行环境中的变量没有引用这些元素了。标记活动对象。

2. 清除：将垃圾数据进行清除

3. 产生内存碎片：对一块内存多次执行标记-清除算法后，会产生大量不连续的内存碎片，而碎片过多将导致大对象无法分配到足够的连续内存。

**标记-整理算法**

1. 标记：同标记-清除算法

2. 整理：让所有存活的对象都向内存的一端移动

3. 清除：清理掉端边界以外的内存

**V8 引擎使用副垃圾回收器与主垃圾回收器进行垃圾回收，但是，由于 JS 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JS 脚本暂停下来，带垃圾回收完后再恢复脚本执行。这种行为叫全停顿**。

为了降低**老生代**垃圾回收造成的卡顿，V8 将标记过程分为一个个子标记过程，同时让垃圾回收标记和 JS 应用逻辑交替执行，直到标记阶段完成。把这个算法称为**增量标记(Incremental Marking)算法**。

> 垃圾回收机制只是清除局部变量——也就是函数内部的变量，函数外部的变量基本是全局变量，只有在页面被关闭时才会被清理。

**扩展**

在 V8 引擎中，被限制了内存的使用大小——64 位约 1.4G/1464M，32 位约 0.7G/732M。

通常，JS 中大多数对象的存活周期较短，大部分经过一次垃圾回收后就被释放。为了提高回收率，才将堆分成新生代与老生代两个区域。

新生区通常只支持 1~8M 的容量，而老生区可支持大容量，对这两个区域分别使用不同的垃圾回收器进行垃圾回收。

1. 副垃圾回收器 - Scavenge：负责新生代垃圾回收

2. 主垃圾回收器 - Mark-Sweep & Mark-Compact：负责老生代垃圾回收

> Savenge 算法是牺牲空间换时间的算法，将新生代划分成两个区域`from-space`与`to-space`。JS 中任何对象的声明所有获取的空间都会放在`from-space`空间中。

**垃圾回收机制如何知道对象是活动与非活动**？

涉及对象可达概念，从初始根对象（window，global）的指针开始，这个根指针对象被称为根集（root set），从该根集向下搜索其子节点，被搜索到的子节点说明该节点的引用对象可达，并为其留下标记。那么未被标记的内存对象表示不可达，需要被回收。

**新生代中的对象什么时候变成老生代对象**？

实际上，新生代中，进行了进一步划分，分为`nursery(幼儿园)`子代，`intermediate(中学)`子代两个区域，所有对象第一次分配内存会被放到`nursery`子代中，如果经过下一次垃圾回收后，对象还存在，就放入`intermediate`子代中，再进过下一次垃圾回收后，若对象还存在新生代中，副垃圾回收器就会将该对象放入老生代中。_该移动过程称为晋升_。

---

- CSRF 攻击是什么？

> 跨站点请求伪造，盗用用户身份发起请求，Cross-site request forgery，XSS——cross-site scripting 跨站脚本攻击

> 主要利用 cookie 进行攻击

跨站点请求伪造，与 XSS 一样，有着巨大的危害。攻击者盗用用户身份，以用户的身份发送恶意请求，但该请求对服务器是合理的。

**原理**：

用户打开浏览器，访问目标网站 A，输入用户名与密码请求登录；用户信息在通过认证后，网站 A 产生一个 cookie 信息返回给浏览器。此时，用户可正常发送请求到网站 A

**当用户没有退出网站 A 时**，在同一浏览器打开网站 B，网站 B 收到用户请求后，返回一些攻击代码，同时发出请求(例如自动请求的表单)，要求访问网站 A。浏览器收到这些攻击代码后，根据网站 B 的请求在用户不知情的情况下以用户的权限操作了 cookie 并向网站 A 服务器发起合法请求。

**预防手段**

1. 使用验证码：在表单中添加随机数字或字母，强制用户与应用进行交互

2. HTTP 中 Referer 字段：检查是否从正确的域名访问过来，该字段记录 HTTP 请求的来源。

3. 使用 token 验证：在 HTTP 请求中添加 token 字段，并在服务器设立拦截器验证 token，若 token 不对，则拒绝请求。

> Referer 实现简单，同时无需修改现存的代码逻辑，但不同浏览器实现该字段的方式不一样，这等同于将安全性交给浏览器实现。使用 token 则比 referer 更安全一点。将 token 放到 HTTP 自定的请求头中也解决了使用 get 与 post 方式传参的不便性。

- XSS 攻击是什么？

> 跨站点脚本攻击，向目标网站插入恶意代码，大量用户访问网站时运行恶意脚本获取信息。

XSS 为跨站点脚本攻击 Cross-site scripting，不写成 CSS 是为了与样式文件缩写进行区分，攻击者可以通过向 Web 页面里插入`script`代码，当用户浏览这个页面时，就会运行被插入的代码，达到攻击者的目的。

> 页面中，只要是在`script`标签内地东西都会被当做正常的 js 脚本执行，常见的情况为用户输入评论时，若没有对输入过滤，攻击者就可以将评论写成`<script>console.log('attack')</script>`，一旦该评论被服务器放到网页上，就会在控制台输出 attack。

XSS 一般的危害为泄露用户的登录信息 cookie，攻击者可以通过 cookie 绕过登入步骤直接进入站点。

XSS 通常分为反射型与存储型。反射型是临时通过 url 访问网站，网站服务端将恶意代码从 url 中取出，拼接在 HTML 中返回给浏览器，用户就会执行恶意代码。存储型就是将恶意代码以留言的形式保存在服务器数据库中，任何访问网站的人都会收到攻击。

预防 XSS 的基本方案就是对数据进行严格的输出编码，如 HTML 元素编码，JS 编码，css 编码，url 编码等。

**扩展**

1. 获取 cookie： 网站登录常用 cookie 作为某个用户身份的验证，是服务器返回的一串字符，可以用来绕过密码登录，当空间、论坛等地方能够被插入`script`代码时，所有用户都会面临攻击。

2. 恶意跳转：页面中插入`window.location.href`进行跳转

3. 反射型 xss：get 方法

4. 存储型 xss：post 方法

防御 XSS 攻击：浏览器的防御与"X-XSS-Protection"有关，默认为 1，开启防御。可以预防反射型 xss，但作用有限，只能防御注入到 HTML 节点内或属性上的 xss，如 url 上有 script 标签。

预防 HTML 节点内容的 xss 攻击：对标签符号进行转义。属性预防：对双引号进行转义（要求属性必须带引号）。预防 JS 代码：将数据进行 JSON 序列化。

防御富文本：较为复杂，通过白名单方式过滤允许的 HTML 标签与属性进行防御。

开启浏览器 XSS 防御，禁止 JS 读取某些敏感 cookie。

### 代码

事件循环中，`var`与`let`会后不同的结果，网上说法为，let 改变了原本的作用域链形式，函数作用域变成块级作用域。效果如下：

```js
for(var i = 0; i < 6; i++) {
  setTimeout(() => {
    console.log(i)
  }, 1000)
}
// print 6 6 6 6 6 6

for(let i = 0; i < 6; i++) {
  setTimeout(() => {
    console.log(i)
  }, 1000)
}
// 0 1 2 3 4 5
```

### others

- 浏览器的渲染过程

1. 浏览器获取到 html 资源并解析 DOM 树

2. 解析到 css 后生成 css 规则树（style rules）

3. 当 dom 树与 css 规则树都生成后，通过两者生成渲染树（render tree）

4. 渲染树构建完成后，浏览器开始计算元素的大小和位置（layout）

5. 根据计算的节点信息，将内容绘制到屏幕上（painting）

#### JWT

JWT(json web token)出现的原因是因为服务器发给浏览器的信息是存在浏览器本地的，当服务器再次收到浏览器中附带的消息时，无法验证该消息的正确性（是否被修改，伪造等）。

为了解决上面的问题，可以在服务器设置一个秘钥，将发送给浏览器的验证信息通过该秘钥进行加密，将得到的结果与验证信息一起发给浏览器，当后续收到浏览器的附带信息时，将该信息通过秘钥进行一次加密，若得到的结果与附带信息中的结果不同，则认为该信息不可信。

> 设浏览器发送的消息为 A，将 A 通过加密，得到 key。将 A.key 发送给浏览器，后续收到的浏览器发来的 A.key 时，先对 A 进行加密，若得到的 key，与 A.key 中的 key 不相同，则认为信息被篡改。

而 JWT 就是执行上面这个操作的一套标准，分为三部分，每个部分通过`.`分割。

1. header：记录本次 JWT 使用的加密算法，类型等，基本是不变的（常用的是 HS256 算法），是一个对象，采用 base64 编码

2. playload：一些用户信息（不要放敏感信息），采用 base64 编码

3. Signature：前面两部分通过秘钥加密后的结果，同样采用了 base64 编码

> 与 session 的区别：session 是存储在服务器中，JWT 存储在客户端中。

#### 浏览器的缓存机制

> 浏览器可以根据相应报文中的缓存标识决定是否将内容缓存。是则将请求结果与缓存标识存入浏览器。

1. 每次请求前，在缓存中查找是否请求结果与缓存标识

2. 没有则发送新的请求，每次得到新的请求结果，都将结果与缓存标识存入缓存中。
